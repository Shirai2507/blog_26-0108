---
title: "Laravel6 サービスプロバイダとビューコンポーザ"
date: "2026-01-16"
category: "Laravel"
description: "Laravel6のサービス、サービスコンテナ、サービスプロバイダ、ビューコンポーザ周りの機能を解説。register(), boot(), singleton(), View::composer(), with()"
slug: "Laravel6_26-0116-1528"
thumbnail: "/images/git_26-0110-1751_img01.png"
---
<br>

## サービスプロバイダのクラスを作成

サービスプロバイダの「DemoServiceProvider」クラスを作るコマンド。
```
php artisan make:provider DemoServiceProvider
```
<br>

上記コマンドで作成されたサービスプロバイダのファイル。(簡略)
```php
// app\providers\DemoServiceProvider.php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
class DemoServiceProvider extends ServiceProvider
{
    public function register() {}
    public function boot() {}
}
```
<br><br>

### リクエストが来てからのコード実行順序
サービスプロバイダを含めたコード実行順序リスト。厳密には違うかもしれないが、ざっくりと整理&イメージできるよう羅列。

1. リクエストが来てLaravelプログラム起動
2. サービスプロバイダの`register()`実行
3. サービスプロバイダの`boot()`実行
4. ルート、コントローラ実行
5. レンダリングするビューを指定
6. ビューがビューコンポーザに登録されている場合、そのビューへデータを渡す。
7. ビューをレンダリング
8. レスポンス
<br><br>

### 作成したサービスプロバイダを有効化

配列「providers」の要素として、作成したサービスプロバイダのクラスを追加。これでサービスプロバイダが機能する。
```php
// config/app.php
'providers' => [
    // ... (いろんなクラスが要素として並んでいる)
    App\Providers\DemoServiceProvider::class,
],
```
<br><br>

## サービスのクラス作成

コントローラに計算や加工のコードをベタ書きすると、肥大化して読みにくい。だから処理をまとめたクラスを別個で用意しておき、必要に応じて呼び出す。このクラスが**サービス**である。

<hr>

例えば、下記のようなクラスをサービスとして用意しておく。サービス自体は何の変哲もないただのクラスである。
```php
// app/Services/GreetingService.php
namespace App\Services;
class GreetingService
{
    public function makeMessage(string $name): string
    {
        return "こんにちは、{$name}さん！";
    }
}
```
<br>

ただのクラスなので、普通に new でインスタンス化して使えたりもする。
```php
// routes/web.php
use App\Services\GreetingService;
Route::get('/greet', function () {
    $service = new GreetingService();   // 普通に new
    $message = $service->makeMessage('たろう');
    return view('greet', compact('message'));
});
```
```html
<!-- resources/views/greet.blade.php -->
<h1>サービスの結果</h1>
<p>{{ $message }}</p>
```
結果表示
>サービスの結果<br>
>こんにちは、たろうさん！

<br><br>

### サービスプロバイダの register() にサービスを登録

事前にサービスを登録しておくことで、毎回 new でインスタンス化しなくてもサービスを利用可能にする。

<hr>

サービスの「GreetingService」クラスが呼ばれた際の挙動を登録。ここでは単純に当該クラスのインスタンスを返す処理にしている。
- $this->app: 必要に応じてサービスをどのように使用可能にするか登録しておける機能。この機能は**サービスコンテナ**と呼ばれる。
- singleton(): 第1引数で指定したクラスが呼ばれた際、第2引数に設定した方法で当該クラスのインスタンスを返す。以降、当該クラスが呼ばれた場合、最初に作ったインスタンスを使いまわす。一方、呼ばれるたびに新しくインスタンスを作る`bind()`というメソッドもある。
- $app: singleton()の第2引数、その無名関数の引数は**サービスコンテナ**であり、関数内で**サービスコンテナ**の機能を使えるようにするためのもの。特に気にせず「$app」は固定と思っておけばよし。
```php
// app\providers\DemoServiceProvider.php
use App\Services\GreetingService;
class DemoServiceProvider extends ServiceProvider
{
    public function register() {
        $this->app->singleton(GreetingService::class, function ($app) {
            return new GreetingService();
        }); // 追加コード
    }
    public function boot() {}
}
```
<br>

サービスコンテナに登録した方法でサービスの「GreetingService」クラスのインスタンスを用意して返す。これにより、new しなくても当該サービスを利用できる。<br>
`app()`はサービスコンテナへ要求するメソッド。
```php
// routes/web.php
use App\Services\GreetingService;
Route::get('/greet-container', function () {
    $service = app(GreetingService::class); // コレ
    $message = $service->makeMessage('はなこ');
    return view('greet', compact('message'));
});
```
<br><br>

## サービスプロバイダの boot() にビューコンポーザを登録


<br><br>
